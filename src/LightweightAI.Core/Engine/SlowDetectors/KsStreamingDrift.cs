// Project Name: LightweightAI.Core
// File Name: KsStreamingDrift.cs
// Author: AutoGenerated
// License: All Rights Reserved. No use without consent.
// Do not remove file headers

using LightweightAI.Core.Abstractions;

namespace LightweightAI.Core.Engine.SlowDetectors;

/// <summary>
/// Simple streaming Kolmogorov-Smirnov style drift estimator maintaining two fixed-size windows
/// (reference and recent). Periodically (every CompareInterval events) computes an approximate KS
/// statistic using binned empirical CDFs. Stub thresholding logic sets drift when statistic exceeds
/// <see cref="_threshold"/>.
/// </summary>
public sealed class KsStreamingDrift : IDriftDetector
{
    public string Name => "ks_stream";

    private readonly int _refSize;
    private readonly int _curSize;
    private readonly int _bins;
    private readonly double _threshold;
    private readonly int _compareInterval;

    private readonly Queue<double> _reference = new();
    private readonly Queue<double> _current = new();
    private long _seen;

    public KsStreamingDrift(int referenceSize = 2048, int currentSize = 512, int bins = 32, double threshold = 0.35, int compareInterval = 256)
    {
        _refSize = referenceSize;
        _curSize = currentSize;
        _bins = bins;
        _threshold = threshold;
        _compareInterval = compareInterval;
    }

    public double Update(double value, DateTimeOffset timestampUtc, out bool isDrift)
    {
        _seen++;
        _current.Enqueue(value);
        if (_current.Count > _curSize) _current.Dequeue();

        if (_reference.Count < _refSize)
            _reference.Enqueue(value);
        else if (_seen % 17 == 0) // slow decay sampling
        {
            _reference.Dequeue();
            _reference.Enqueue(value);
        }

        double stat = 0.0;
        isDrift = false;

        if (_reference.Count > _bins && _current.Count > _bins && _seen % _compareInterval == 0)
        {
            // Build histograms
            var min = Math.Min(_reference.Min(), _current.Min());
            var max = Math.Max(_reference.Max(), _current.Max());
            if (max <= min) return 0;
            var refHist = new double[_bins];
            var curHist = new double[_bins];
            var width = (max - min) / _bins;
            foreach (var v in _reference)
            {
                var idx = (int)Math.Clamp((v - min) / width, 0, _bins - 1);
                refHist[idx]++;
            }
            foreach (var v in _current)
            {
                var idx = (int)Math.Clamp((v - min) / width, 0, _bins - 1);
                curHist[idx]++;
            }
            // Convert to cumulative probability
            double refCum = 0, curCum = 0;
            for (int i = 0; i < _bins; i++)
            {
                refCum += refHist[i] / _reference.Count;
                curCum += curHist[i] / _current.Count;
                var diff = Math.Abs(refCum - curCum);
                if (diff > stat) stat = diff;
            }
            if (stat >= _threshold) isDrift = true;
        }

        return stat;
    }
}