// Project Name: LightweightAI.Core
// File Name: IngestionConfigurator.cs
// Author: AutoGenerated
// License: All Rights Reserved. No use without consent.
// Do not remove file headers

using System.Text.Json;
using System.Text.Json.Serialization;
using LightweightAI.Core.Abstractions;
using LightweightAI.Core.Engine;
using LightweightAI.Core.Loaders.Sysmon;
using LightweightAI.Core.Loaders.Generic;
using LightweightAI.Core.Loaders.PerMon;
using LightweightAI.Core.Loaders.Windows;

using Microsoft.Extensions.DependencyInjection;


namespace LightweightAI.Core.Engine.Intake;

/// <summary>
/// Parses a JSON ingestion configuration document and registers the corresponding source loaders
/// into the <see cref="ISourceRegistry"/>.
/// </summary>
public interface IIngestionConfigurator
{
    void Configure(ISourceRegistry registry, IServiceProvider services, string jsonConfig);
}

internal sealed class IngestionConfigurator : IIngestionConfigurator
{
    private sealed record Root([property: JsonPropertyName("sources")] List<SourceDef> Sources);
    private sealed record SourceDef(
        [property: JsonPropertyName("key")] string Key,
        [property: JsonPropertyName("type")] string Type,
        [property: JsonPropertyName("params")] JsonElement? Params);

    public void Configure(ISourceRegistry registry, IServiceProvider services, string jsonConfig)
    {
        Root? root = JsonSerializer.Deserialize<Root>(jsonConfig, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
        if (root == null) return;
        foreach (var src in root.Sources)
        {
            try
            {
                var (loader, parameters) = CreateLoader(src, services);
                if (loader is not null)
                    registry.Register(src.Key, loader, parameters);
            }
            catch
            {
                // Swallow individual source failures to keep startup resilient
            }
        }
    }

    private static (ISourceLoader? loader, IReadOnlyDictionary<string,string>? parameters) CreateLoader(SourceDef def, IServiceProvider sp)
    {
        var type = def.Type.ToLowerInvariant();
        var dict = new Dictionary<string,string>(StringComparer.OrdinalIgnoreCase);
        if (def.Params is { } p && p.ValueKind == JsonValueKind.Object)
        {
            foreach (var prop in p.EnumerateObject())
                dict[prop.Name] = prop.Value.ToString();
        }

        switch (type)
        {
            case "sysmon":
                return (ActivatorUtilities.CreateInstance<SysmonLoader>(sp), dict);
            case "eventlog":
            case "wevt":
                var channels = def.Params is { } && def.Params.Value.TryGetProperty("channels", out var chEl) && chEl.ValueKind == JsonValueKind.Array
                    ? chEl.EnumerateArray().Select(e => e.GetString() ?? string.Empty).Where(s => !string.IsNullOrWhiteSpace(s)).ToArray()
                    : new[] { "System", "Application" };
                var xpath = def.Params is { } && def.Params.Value.TryGetProperty("xpath", out var xEl) ? xEl.GetString() : null;
                return (new EventLogMultiChannelLoader(channels, xpath), dict);
            case "perfmon":
                return (ActivatorUtilities.CreateInstance<PerfmonLoader>(sp), dict);
            case "health":
                return (new HealthStatusLoader(), dict);
            case "trace":
            case "etw":
                var providers = def.Params is { } && def.Params.Value.TryGetProperty("providers", out var provEl) && provEl.ValueKind == JsonValueKind.Array
                    ? provEl.EnumerateArray().Select(e => e.GetString() ?? string.Empty).Where(s => !string.IsNullOrWhiteSpace(s))
                    : new[] { "Microsoft-Windows-Kernel-Process" };
                return (new EtwRealTimeLoader("MiniAI-RT", providers), dict);
            case "wmi":
                var wql = def.Params is { } && def.Params.Value.TryGetProperty("wql", out var wqlEl) ? (wqlEl.GetString() ?? "SELECT * FROM Win32_OperatingSystem") : "SELECT * FROM Win32_OperatingSystem";
                return (new WmiQueryLoader(wql), dict);
            case "generic":
                // generic JSON feed: require path parameter; parser resolves at runtime
                return (ActivatorUtilities.CreateInstance<GenericFeedLoader<Dictionary<string, object?>>>(sp), dict);
            default:
                return (null, null);
        }
    }
}