// Project Name: LightweightAI.Core
// File Name: RollingWindowAggregator.cs
// Author: AutoGenerated
// License: All Rights Reserved. No use without consent.
// Do not remove file headers

using System.Collections.Concurrent;

namespace LightweightAI.Core.Engine.Intake;

/// <summary>
/// Maintains simple rolling (time based) statistics per source key for incoming encoded events.
/// Window length is fixed; older samples are evicted on insert. Computes snapshot statistics
/// required to populate <see cref="Snapshot"/> and <see cref="AggregatedMetric"/> records.
/// </summary>
internal sealed class RollingWindowAggregator
{
    private readonly TimeSpan _windowLength;

    private readonly ConcurrentDictionary<string, DequeEntry> _state = new();

    private sealed class DequeEntry
    {
        public readonly LinkedList<(DateTimeOffset ts, double value)> Samples = new();
        public double Sum; // sum of values
        public double SumSq; // sum of squares
        public double Ema; // exponential moving average
        public DateTimeOffset LastTs;
    }

    public RollingWindowAggregator(TimeSpan windowLength)
    {
        _windowLength = windowLength;
    }

    public (AggregatedMetric metric, Snapshot snapshot) Add(string key, DateTimeOffset ts, double value)
    {
        var entry = _state.GetOrAdd(key, _ => new DequeEntry());
        entry.LastTs = ts;
        entry.Samples.AddLast((ts, value));
        entry.Sum += value;
        entry.SumSq += value * value;

        // EMA (alpha derived from window size ~ simple heuristic)
        var alpha = Math.Clamp(2.0 / Math.Max(2.0, _windowLength.TotalSeconds / 5.0 + 1.0), 0.01, 0.5);
        entry.Ema = entry.Samples.Count == 1 ? value : (float)(alpha * value + (1 - alpha) * entry.Ema);

        // Evict old
        var cutoff = ts - _windowLength;
        while (entry.Samples.First is not null && entry.Samples.First.Value.ts < cutoff)
        {
            var old = entry.Samples.First.Value;
            entry.Samples.RemoveFirst();
            entry.Sum -= old.value;
            entry.SumSq -= old.value * old.value;
        }

        var count = entry.Samples.Count;
        var mean = count > 0 ? entry.Sum / count : 0.0;
        var variance = count > 1 ? Math.Max(0.0, (entry.SumSq - count * mean * mean) / (count - 1)) : 0.0;
        var stdDev = Math.Sqrt(variance);
        var firstTs = entry.Samples.First?.Value.ts ?? ts;
        var trendDelta = value - mean;

        var metric = new AggregatedMetric(
            Key: key,
            WindowStart: firstTs,
            WindowEnd: ts,
            Count: count,
            WeightedScore: mean,
            Dimensions: System.Collections.Immutable.ImmutableDictionary<string, double>.Empty.Add("std_dev", stdDev)
        );

        var snap = new Snapshot(
            At: ts,
            Count: count,
            Sum: entry.Sum,
            Mean: mean,
            StdDev: stdDev,
            Ema: entry.Ema,
            TrendDelta: trendDelta
        );
        return (metric, snap);
    }
}