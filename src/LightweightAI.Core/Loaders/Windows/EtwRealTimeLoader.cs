// Project Name: LightweightAI.Core
// File Name: EtwRealTimeLoader.cs
// Author: AutoGenerated
// License: All Rights Reserved. No use without consent.
// Do not remove file headers

using LightweightAI.Core.Abstractions;

namespace LightweightAI.Core.Loaders.Windows;

/// <summary>
/// Real-time ETW (Event Tracing for Windows) session loader. Attempts to attach to one or more ETW providers
/// and stream events as <see cref="RawEvent"/> instances. Uses TraceEvent library when available; otherwise
/// acts as a stub. Provider GUIDs or names are supplied via constructor.
/// </summary>
public sealed class EtwRealTimeLoader : ISourceLoader, IDisposable
{
    private readonly string _sessionName;
    private readonly string[] _providers; // provider names or GUID strings
    private bool _initialized;

#if WINDOWS
    private Microsoft.Diagnostics.Tracing.Session.TraceEventSession? _session;
#endif

    public EtwRealTimeLoader(string sessionName, IEnumerable<string> providers)
    {
        _sessionName = sessionName;
        _providers = providers.Distinct(StringComparer.OrdinalIgnoreCase).ToArray();
    }

    public async IAsyncEnumerable<RawEvent> LoadAsync(SourceRequest request, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
    {
#if WINDOWS
        EnsureSession();
        if (_session is null)
            yield break;

        // Channel used to bridge callback based ETW into async enumeration.
        var channel = System.Threading.Channels.Channel.CreateUnbounded<RawEvent>(new System.Threading.Channels.UnboundedChannelOptions { SingleWriter = false, SingleReader = true });

        void OnEvent(Microsoft.Diagnostics.Tracing.TraceEvent data)
        {
            if (ct.IsCancellationRequested) return;
            try
            {
                var fields = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase)
                {
                    ["ProviderName"] = data.ProviderName,
                    ["EventName"] = data.EventName,
                    ["Opcode"] = data.OpcodeName,
                    ["Task"] = data.TaskName,
                    ["Id"] = data.ID,
                    ["Keywords"] = (ulong)data.Keywords,
                    ["Level"] = data.Level.ToString()
                };
                for (int i = 0; i < data.PayloadNames.Length; i++)
                    fields[$"Payload.{data.PayloadNames[i]}"] = data.PayloadValue(i);

                var raw = new RawEvent(
                    request.SourceKey,
                    data.ID,
                    data.TimeStamp.ToUniversalTime(),
                    Environment.MachineName,
                    null,
                    NormalizeSeverity(data.Level.ToString()),
                    fields,
                    $"etwrt:{data.ProviderName}:{data.ID}:{data.TimeStamp.Ticks}" );
                channel.Writer.TryWrite(raw);
            }
            catch { /* swallow to avoid session termination */ }
        }

        using var source = new Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource(_session.FileName); // fallback; real-time callback below

        // Real-time processing using TraceEvent's dynamic parser
        var task = Task.Run(async () =>
        {
            try
            {
                using var traceSource = new Microsoft.Diagnostics.Tracing.TraceEventSession(_sessionName);
                foreach (var p in _providers)
                {
                    try { traceSource.EnableProvider(p); } catch { }
                }
                traceSource.Source.AllEvents += OnEvent;
                traceSource.Source.Process();
            }
            catch { }
            finally { channel.Writer.TryComplete(); }
        }, ct);

        await foreach (var item in channel.Reader.ReadAllAsync(ct))
            yield return item;
#else
        // Non-Windows stub
        await Task.CompletedTask;
        yield break;
#endif
    }

#if WINDOWS
    private void EnsureSession()
    {
        if (_initialized) return;
        _initialized = true;
        try
        {
            _session = new Microsoft.Diagnostics.Tracing.Session.TraceEventSession(_sessionName, null) { StopOnDispose = true };
            foreach (var p in _providers)
            {
                try { _session.EnableProvider(p); } catch { }
            }
        }
        catch
        {
            _session = null;
        }
    }
#endif

    private static string NormalizeSeverity(string level) => level switch
    {
        "Critical" => "Critical",
        "Error" => "Error",
        "Warning" => "Warn",
        _ => "Info"
    };

    public void Dispose()
    {
#if WINDOWS
        _session?.Dispose();
#endif
    }
}
