// Project Name: LightweightAI.Core
// File Name: WmiQueryLoader.cs
// Author: AutoGenerated
// License: All Rights Reserved. No use without consent.
// Do not remove file headers

using LightweightAI.Core.Abstractions;

namespace LightweightAI.Core.Loaders.Windows;

/// <summary>
/// Executes periodic WMI queries (e.g., Win32_OperatingSystem, Win32_Process) and emits result rows
/// as RawEvent objects for diagnostic feature generation. On non-Windows hosts produces no events.
/// </summary>
public sealed class WmiQueryLoader : ISourceLoader
{
    private readonly string _wql;
    private readonly TimeSpan _interval;
    private readonly int _maxIterations;

    public WmiQueryLoader(string wql, TimeSpan? interval = null, int maxIterations = 100)
    {
        _wql = wql;
        _interval = interval ?? TimeSpan.FromSeconds(10);
        _maxIterations = maxIterations;
    }

    public async IAsyncEnumerable<RawEvent> LoadAsync(SourceRequest request, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
    {
#if WINDOWS
        var scope = new System.Management.ManagementScope("\\\\.\\root\\cimv2");
        var query = new System.Management.ObjectQuery(_wql);
        for (int iter = 0; iter < _maxIterations; iter++)
        {
            ct.ThrowIfCancellationRequested();
            try
            {
                using var searcher = new System.Management.ManagementObjectSearcher(scope, query);
                foreach (System.Management.ManagementObject obj in searcher.Get())
                {
                    var dict = new Dictionary<string, object?>();
                    foreach (var prop in obj.Properties)
                        dict[prop.Name] = prop.Value;
                    yield return new RawEvent(request.SourceKey, 0, DateTimeOffset.UtcNow, Environment.MachineName, null, "Info", dict, $"wmi:{iter}");
                }
            }
            catch { /* ignore individual iteration failures */ }
            await Task.Delay(_interval, ct);
        }
#else
        await Task.CompletedTask;
        yield break;
#endif
    }
}
