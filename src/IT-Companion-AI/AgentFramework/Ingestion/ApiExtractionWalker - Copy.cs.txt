using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

#region DTOs

public sealed class ApiTypeExtraction
{
    public string SemanticUid { get; set; }
    public string Name { get; set; }
    public string Kind { get; set; }
    public string Accessibility { get; set; }
    public List<string> Modifiers { get; set; }
    public string BaseType { get; set; }
    public List<string> Interfaces { get; set; }
    public List<string> GenericParameters { get; set; }
    public List<string> GenericConstraints { get; set; }
    public List<string> Attributes { get; set; }
    public string SummaryXml { get; set; }
    public string Namespace { get; set; }
    public string DeclaringType { get; set; }
    public string AssemblyName { get; set; }
    public string SourceFilePath { get; set; }
    public int StartLine { get; set; }
    public int EndLine { get; set; }
}

public sealed class ApiMemberExtraction
{
    public string SemanticUid { get; set; }
    public string Name { get; set; }
    public string Kind { get; set; }
    public string Accessibility { get; set; }
    public List<string> Modifiers { get; set; }
    public string ReturnType { get; set; }
    public List<ApiParameterExtraction> Parameters { get; set; }
    public List<string> GenericParameters { get; set; }
    public List<string> GenericConstraints { get; set; }
    public List<string> Attributes { get; set; }
    public string SummaryXml { get; set; }
    public string Namespace { get; set; }
    public string DeclaringType { get; set; }
    public string AssemblyName { get; set; }
    public string SourceFilePath { get; set; }
    public int StartLine { get; set; }
    public int EndLine { get; set; }
}

public sealed class ApiParameterExtraction
{
    public string SemanticUid { get; set; }
    public string Name { get; set; }
    public string Type { get; set; }
    public string Nullable { get; set; }
    public string Modifier { get; set; }
    public string DefaultValue { get; set; }
    public List<string> Attributes { get; set; }
}

public sealed class ApiExtractionResult
{
    public ApiExtractionResult(
        IReadOnlyList<ApiTypeExtraction> types,
        IReadOnlyList<ApiMemberExtraction> members)
    {
        Types = types;
        Members = members;
    }

    public IReadOnlyList<ApiTypeExtraction> Types { get; }
    public IReadOnlyList<ApiMemberExtraction> Members { get; }
}

#endregion

#region Walker

/// <summary>
/// A syntax walker that traverses C# syntax trees to extract API information,
/// including types and members, from the provided semantic model and source code.
/// </summary>
public sealed class ApiExtractionWalker : CSharpSyntaxWalker
{
    private readonly SemanticModel _semanticModel;
    private readonly string _filePath;
    private readonly string _assemblyName;
    private readonly CancellationToken _cancellationToken;

    public List<ApiTypeExtraction> Types { get; } = new();
    public List<ApiMemberExtraction> Members { get; } = new();

    public ApiExtractionWalker(
        SemanticModel semanticModel,
        string filePath,
        string assemblyName,
        CancellationToken cancellationToken)
        : base(SyntaxWalkerDepth.StructuredTrivia)
    {
        _semanticModel = semanticModel ?? throw new ArgumentNullException(nameof(semanticModel));
        _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
        _assemblyName = assemblyName ?? throw new ArgumentNullException(nameof(assemblyName));
        _cancellationToken = cancellationToken;
    }

    public override void Visit(SyntaxNode? node)
    {
        _cancellationToken.ThrowIfCancellationRequested();
        base.Visit(node);
    }

    public override void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        ExtractNamedType(node, "Class");
        base.VisitClassDeclaration(node);
    }

    public override void VisitStructDeclaration(StructDeclarationSyntax node)
    {
        ExtractNamedType(node, "Struct");
        base.VisitStructDeclaration(node);
    }

    public override void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
        ExtractNamedType(node, "Interface");
        base.VisitInterfaceDeclaration(node);
    }

    public override void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
        ExtractEnum(node);
        base.VisitEnumDeclaration(node);
    }

    public override void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
        ExtractDelegate(node);
        base.VisitDelegateDeclaration(node);
    }

    public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        ExtractMethod(node);
        base.VisitMethodDeclaration(node);
    }

    public override void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
        ExtractProperty(node);
        base.VisitPropertyDeclaration(node);
    }

    public override void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
        ExtractIndexer(node);
        base.VisitIndexerDeclaration(node);
    }

    public override void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
        ExtractField(node);
        base.VisitFieldDeclaration(node);
    }

    public override void VisitEventDeclaration(EventDeclarationSyntax node)
    {
        ExtractEvent(node);
        base.VisitEventDeclaration(node);
    }

    public override void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
        ExtractEventField(node);
        base.VisitEventFieldDeclaration(node);
    }

    private void ExtractNamedType(TypeDeclarationSyntax node, string kind)
    {
        var symbol = _semanticModel.GetDeclaredSymbol(node) as INamedTypeSymbol;
        if (symbol == null)
        {
            return;
        }

        var (start, end) = GetSpan(node);

        Types.Add(new ApiTypeExtraction
        {
            SemanticUid = GenerateSemanticUid(symbol),
            Name = symbol.Name,
            Kind = kind,
            Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
            Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
            BaseType = symbol.BaseType?.ToDisplayString(),
            Interfaces = symbol.AllInterfaces
                .Select(i => i.ToDisplayString())
                .Distinct(StringComparer.Ordinal)
                .OrderBy(i => i, StringComparer.Ordinal)
                .ToList(),
            GenericParameters = symbol.TypeParameters.Select(t => t.Name).ToList(),
            GenericConstraints = symbol.TypeParameters
                .SelectMany(tp => tp.ConstraintTypes.Select(ct => ct.ToDisplayString()))
                .Distinct(StringComparer.Ordinal)
                .OrderBy(x => x, StringComparer.Ordinal)
                .ToList(),
            Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
            SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
            Namespace = symbol.ContainingNamespace?.ToDisplayString(),
            DeclaringType = symbol.ContainingType?.ToDisplayString(),
            AssemblyName = _assemblyName,
            SourceFilePath = _filePath,
            StartLine = start,
            EndLine = end
        });
    }

    private void ExtractEnum(EnumDeclarationSyntax node)
    {
        var symbol = _semanticModel.GetDeclaredSymbol(node) as INamedTypeSymbol;
        if (symbol == null)
        {
            return;
        }

        var (start, end) = GetSpan(node);

        Types.Add(new ApiTypeExtraction
        {
            SemanticUid = GenerateSemanticUid(symbol),
            Name = symbol.Name,
            Kind = "Enum",
            Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
            Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
            BaseType = symbol.EnumUnderlyingType?.ToDisplayString(),
            Interfaces = symbol.AllInterfaces
                .Select(i => i.ToDisplayString())
                .Distinct(StringComparer.Ordinal)
                .OrderBy(i => i, StringComparer.Ordinal)
                .ToList(),
            GenericParameters = new List<string>(),
            GenericConstraints = new List<string>(),
            Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
            SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
            Namespace = symbol.ContainingNamespace?.ToDisplayString(),
            DeclaringType = symbol.ContainingType?.ToDisplayString(),
            AssemblyName = _assemblyName,
            SourceFilePath = _filePath,
            StartLine = start,
            EndLine = end
        });
    }

    private void ExtractDelegate(DelegateDeclarationSyntax node)
    {
        var symbol = _semanticModel.GetDeclaredSymbol(node) as INamedTypeSymbol;
        if (symbol == null)
        {
            return;
        }

        var invoke = symbol.DelegateInvokeMethod;
        var (start, end) = GetSpan(node);

        Members.Add(new ApiMemberExtraction
        {
            SemanticUid = GenerateSemanticUid(symbol),
            Name = symbol.Name,
            Kind = "Delegate",
            Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
            Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
            ReturnType = invoke?.ReturnType.ToDisplayString(),
            Parameters = invoke?.Parameters.Select(ConvertParameter).ToList() ?? new List<ApiParameterExtraction>(),
            GenericParameters = symbol.TypeParameters.Select(t => t.Name).ToList(),
            GenericConstraints = symbol.TypeParameters
                .SelectMany(tp => tp.ConstraintTypes.Select(ct => ct.ToDisplayString()))
                .Distinct(StringComparer.Ordinal)
                .OrderBy(x => x, StringComparer.Ordinal)
                .ToList(),
            Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
            SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
            Namespace = symbol.ContainingNamespace?.ToDisplayString(),
            DeclaringType = symbol.ContainingType?.ToDisplayString(),
            AssemblyName = _assemblyName,
            SourceFilePath = _filePath,
            StartLine = start,
            EndLine = end
        });
    }

    private void ExtractMethod(MethodDeclarationSyntax node)
    {
        var symbol = _semanticModel.GetDeclaredSymbol(node) as IMethodSymbol;
        if (symbol == null)
        {
            return;
        }

        var (start, end) = GetSpan(node);

        Members.Add(new ApiMemberExtraction
        {
            SemanticUid = GenerateSemanticUid(symbol),
            Name = symbol.Name,
            Kind = "Method",
            Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
            Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
            ReturnType = symbol.ReturnType.ToDisplayString(),
            Parameters = symbol.Parameters.Select(ConvertParameter).ToList(),
            GenericParameters = symbol.TypeParameters.Select(t => t.Name).ToList(),
            GenericConstraints = symbol.TypeParameters
                .SelectMany(tp => tp.ConstraintTypes.Select(ct => ct.ToDisplayString()))
                .Distinct(StringComparer.Ordinal)
                .OrderBy(x => x, StringComparer.Ordinal)
                .ToList(),
            Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
            SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
            Namespace = symbol.ContainingNamespace?.ToDisplayString(),
            DeclaringType = symbol.ContainingType?.ToDisplayString(),
            AssemblyName = _assemblyName,
            SourceFilePath = _filePath,
            StartLine = start,
            EndLine = end
        });
    }

    private void ExtractProperty(PropertyDeclarationSyntax node)
    {
        var symbol = _semanticModel.GetDeclaredSymbol(node) as IPropertySymbol;
        if (symbol == null)
        {
            return;
        }

        var (start, end) = GetSpan(node);

        Members.Add(new ApiMemberExtraction
        {
            SemanticUid = GenerateSemanticUid(symbol),
            Name = symbol.Name,
            Kind = "Property",
            Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
            Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
            ReturnType = symbol.Type.ToDisplayString(),
            Parameters = new List<ApiParameterExtraction>(),
            GenericParameters = new List<string>(),
            GenericConstraints = new List<string>(),
            Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
            SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
            Namespace = symbol.ContainingNamespace?.ToDisplayString(),
            DeclaringType = symbol.ContainingType?.ToDisplayString(),
            AssemblyName = _assemblyName,
            SourceFilePath = _filePath,
            StartLine = start,
            EndLine = end
        });
    }

    private void ExtractIndexer(IndexerDeclarationSyntax node)
    {
        var symbol = _semanticModel.GetDeclaredSymbol(node) as IPropertySymbol;
        if (symbol == null)
        {
            return;
        }

        var (start, end) = GetSpan(node);

        Members.Add(new ApiMemberExtraction
        {
            SemanticUid = GenerateSemanticUid(symbol),
            Name = "this",
            Kind = "Indexer",
            Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
            Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
            ReturnType = symbol.Type.ToDisplayString(),
            Parameters = symbol.Parameters.Select(ConvertParameter).ToList(),
            GenericParameters = new List<string>(),
            GenericConstraints = new List<string>(),
            Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
            SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
            Namespace = symbol.ContainingNamespace?.ToDisplayString(),
            DeclaringType = symbol.ContainingType?.ToDisplayString(),
            AssemblyName = _assemblyName,
            SourceFilePath = _filePath,
            StartLine = start,
            EndLine = end
        });
    }

    private void ExtractField(FieldDeclarationSyntax node)
    {
        foreach (VariableDeclaratorSyntax variable in node.Declaration.Variables)
        {
            var symbol = _semanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
            if (symbol == null)
            {
                continue;
            }

            var (start, end) = GetSpan(node);

            Members.Add(new ApiMemberExtraction
            {
                SemanticUid = GenerateSemanticUid(symbol),
                Name = symbol.Name,
                Kind = "Field",
                Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
                Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
                ReturnType = symbol.Type.ToDisplayString(),
                Parameters = new List<ApiParameterExtraction>(),
                GenericParameters = new List<string>(),
                GenericConstraints = new List<string>(),
                Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
                SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
                Namespace = symbol.ContainingNamespace?.ToDisplayString(),
                DeclaringType = symbol.ContainingType?.ToDisplayString(),
                AssemblyName = _assemblyName,
                SourceFilePath = _filePath,
                StartLine = start,
                EndLine = end
            });
        }
    }

    private void ExtractEvent(EventDeclarationSyntax node)
    {
        var symbol = _semanticModel.GetDeclaredSymbol(node) as IEventSymbol;
        if (symbol == null)
        {
            return;
        }

        var (start, end) = GetSpan(node);

        Members.Add(new ApiMemberExtraction
        {
            SemanticUid = GenerateSemanticUid(symbol),
            Name = symbol.Name,
            Kind = "Event",
            Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
            Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
            ReturnType = symbol.Type.ToDisplayString(),
            Parameters = GetEventParameters(symbol),
            GenericParameters = new List<string>(),
            GenericConstraints = new List<string>(),
            Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
            SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
            Namespace = symbol.ContainingNamespace?.ToDisplayString(),
            DeclaringType = symbol.ContainingType?.ToDisplayString(),
            AssemblyName = _assemblyName,
            SourceFilePath = _filePath,
            StartLine = start,
            EndLine = end
        });
    }

    private void ExtractEventField(EventFieldDeclarationSyntax node)
    {
        foreach (VariableDeclaratorSyntax variable in node.Declaration.Variables)
        {
            var symbol = _semanticModel.GetDeclaredSymbol(variable) as IEventSymbol;
            if (symbol == null)
            {
                continue;
            }

            var (start, end) = GetSpan(node);

            Members.Add(new ApiMemberExtraction
            {
                SemanticUid = GenerateSemanticUid(symbol),
                Name = symbol.Name,
                Kind = "Event",
                Accessibility = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(),
                Modifiers = node.Modifiers.Select(m => m.Text).OrderBy(m => m, StringComparer.Ordinal).ToList(),
                ReturnType = symbol.Type.ToDisplayString(),
                Parameters = GetEventParameters(symbol),
                GenericParameters = new List<string>(),
                GenericConstraints = new List<string>(),
                Attributes = GetAttributeTypeNames(symbol.GetAttributes()),
                SummaryXml = symbol.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default),
                Namespace = symbol.ContainingNamespace?.ToDisplayString(),
                DeclaringType = symbol.ContainingType?.ToDisplayString(),
                AssemblyName = _assemblyName,
                SourceFilePath = _filePath,
                StartLine = start,
                EndLine = end
            });
        }
    }

    private static List<ApiParameterExtraction> GetEventParameters(IEventSymbol symbol)
    {
        if (symbol.Type is not INamedTypeSymbol delegateType)
        {
            return new List<ApiParameterExtraction>();
        }

        var invoke = delegateType.DelegateInvokeMethod;
        return invoke == null
            ? new List<ApiParameterExtraction>()
            : invoke.Parameters.Select(ConvertParameter).ToList();
    }

    private static ApiParameterExtraction ConvertParameter(IParameterSymbol parameter)
    {
        return new ApiParameterExtraction
        {
            SemanticUid = GenerateSemanticUid(parameter),
            Name = parameter.Name,
            Type = parameter.Type.ToDisplayString(),
            Nullable = parameter.NullableAnnotation.ToString(),
            Modifier = parameter.RefKind.ToString().ToLowerInvariant(),
            DefaultValue = parameter.HasExplicitDefaultValue ? parameter.ExplicitDefaultValue?.ToString() : null,
            Attributes = GetAttributeTypeNames(parameter.GetAttributes())
        };
    }

    private static List<string> GetAttributeTypeNames(IEnumerable<AttributeData> attributes)
    {
        return attributes
            .Select(a => a.AttributeClass?.ToDisplayString())
            .Where(name => !string.IsNullOrWhiteSpace(name))
            .Distinct(StringComparer.Ordinal)
            .OrderBy(name => name, StringComparer.Ordinal)
            .ToList()!;
    }

    private static (int Start, int End) GetSpan(SyntaxNode node)
    {
        FileLinePositionSpan span = node.GetLocation().GetLineSpan();
        return (span.StartLinePosition.Line + 1, span.EndLinePosition.Line + 1);
    }

    private static string GenerateSemanticUid(ISymbol symbol)
    {
        ArgumentNullException.ThrowIfNull(symbol);

        string fqName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        string kind = symbol.Kind.ToString();
        string metadata = symbol.MetadataName;

        return $"{kind}:{fqName}:{metadata}";
    }
}

#endregion

#region Orchestrator

public sealed class ApiExtractionOrchestrator
{
    public async Task<ApiExtractionResult> ExtractAsync(
        Solution solution,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(solution);
                                                                                                                                                                
        var allTypes = new List<ApiTypeExtraction>();
        var allMembers = new List<ApiMemberExtraction>();

        foreach (Project project in solution.Projects.Where(p => p.Language == LanguageNames.CSharp))
        {
            cancellationToken.ThrowIfCancellationRequested();

            Compilation? compilation = await project.GetCompilationAsync(cancellationToken).ConfigureAwait(false);
            if (compilation is null)
            {
                continue;
            }

            string assemblyName = compilation.AssemblyName;

            foreach (Document document in project.Documents.Where(ShouldProcessDocument))
            {
                cancellationToken.ThrowIfCancellationRequested();

                SyntaxNode? syntaxRoot = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);
                if (syntaxRoot is null)
                {
                    continue;
                }

                SemanticModel semanticModel = compilation.GetSemanticModel(syntaxRoot.SyntaxTree);
                var walker = new ApiExtractionWalker(
                    semanticModel,
                    document.FilePath ?? document.Name,
                    assemblyName,
                    cancellationToken);

                walker.Visit(syntaxRoot);

                allTypes.AddRange(walker.Types);
                allMembers.AddRange(walker.Members);
            }
        }

        return new ApiExtractionResult(allTypes, allMembers);
    }

    private static bool ShouldProcessDocument(Document document)
    {
        if (document.SourceCodeKind != SourceCodeKind.Regular)
        {
            return false;
        }

        string? filePath = document.FilePath;
        if (string.IsNullOrWhiteSpace(filePath))
        {
            return true;
        }

        return !IsGeneratedPath(filePath);
    }

    private static bool IsGeneratedPath(string filePath)
    {
        if (ContainsPathSegment(filePath, "obj") ||
            ContainsPathSegment(filePath, "bin"))
        {
            return true;
        }

        string fileName = Path.GetFileName(filePath);
        return fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
               fileName.EndsWith(".g.i.cs", StringComparison.OrdinalIgnoreCase) ||
               fileName.EndsWith(".generated.cs", StringComparison.OrdinalIgnoreCase) ||
               fileName.EndsWith(".designer.cs", StringComparison.OrdinalIgnoreCase);
    }

    private static bool ContainsPathSegment(string filePath, string segment)
    {
        return filePath.IndexOf($"{Path.DirectorySeparatorChar}{segment}{Path.DirectorySeparatorChar}",
                   StringComparison.OrdinalIgnoreCase) >= 0 ||
               filePath.IndexOf($"{Path.AltDirectorySeparatorChar}{segment}{Path.AltDirectorySeparatorChar}",
                   StringComparison.OrdinalIgnoreCase) >= 0;
    }
}

#endregion